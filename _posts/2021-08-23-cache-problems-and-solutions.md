---
layout: post
title: 快取的三大問題與解決方法(雪崩、擊穿、穿透)
tags:
- cache
- backend
---

[comment]: <> (## 什麼是Redis)

[comment]: <> (Redis是 Remote Dictionary Server的簡寫，是一種開源、使用鍵值對&#40;Key-value Pair&#41;儲存資料庫，屬於NoSQL的家族，可用來當做主要資料庫、快取&#40;Cache&#41;或是消息代理&#40;Message Broker&#41;。)

[comment]: <> (由於Redis是對記憶體進行操作，讓它的速度相較於讀取硬碟快上許多，很適合用來當作快取的Server，在高流量的Web可以保護Primary DB不被高流量擊潰，與Memcached相比，穩定性更好。)

在高併發，高流量的應用中，快取扮演重要的角色，確保主資料庫不會因為過多訪問被癱瘓，這篇在探討使用快取會碰到三個問題與解決方法

1. 快取雪崩 Cache Avalanche
2. 快取擊穿 Hotspot Invalid
3. 快取穿透 Cache Penetration

-------

## 快取雪崩 Cache Avalanche
快取可以想做成是在公司第一線的客服部門，平常由客服主管來制定回覆SOP，每個客服都遵照客服主管提供的資訊處理客訴

所有客戶一進門都先會先問第一線客服找答案，客服無法處理才往上找客服經理處理，如果今天所有客服同一時間一起下班，所有的客人就會直接衝到客服經理面前理論，日常業務可能就會癱瘓。

假設有個電商促銷活動是在凌晨12點開始搶限量商品，所有快取重設時間剛好是凌晨12點，開放搶購時，主資料庫人潮癱瘓
快取全部在同一時間失效，大量的訪問就會直接衝進主資料庫，這就是快取雪崩。

### 解決方法

可以在生成快取的失效時間點加上一點隨機的時間，減少每段時間內的失效的數量，也可以不指定失效時間，用其他方法讓快取淘汰而失效。

-------

## 快取擊穿 Hotspot Invalid

快取擊穿有點像快取雪崩，只不過沒有大量不同的訪問，而是有個熱門的Key被高頻率的訪問，當快取失效的那一瞬間，大量Request就會直接癱瘓主資料庫。


### 解決方法
#### 快取永不失效

跟快取雪崩一樣，都是發生在快取失效的瞬間，所以最直覺解決方法就是快取永不失效，再透過其他方式定期去更新快取

#### 多線程加鎖

當快取失效的時候，只讓一個線程建立快取，其他線程先擋下，排隊等快取建立完之後，才會讓他們讀取快取，但這也會造成延遲的問題。

#### 提前處理

在快取設定一個超時值，當發現超時值比實際失效時間小的時候，就先預先作業，處理更新快取跟延長失效時間，不讓快取真的失效

-------

## 快取穿透 Cache Penetration

快取穿透相較於前兩個使用情境，算是一種比較惡意的攻擊，就是故意訪問不存在的資料，因為資料不存在就不會建立在快取中，能繞過快取直接訪問主資料庫造成癱瘓。


### 解決方法

#### 增加驗證

在應用層驗證，預先擋下不合理的訪問，例如`id < 0`或是身份證字號只有三碼。

#### 增加快取

如果快取沒有，資料庫也沒有，可以把null的結果存在快取中，避免單一id被反覆攻擊。

#### Bloom Filter

Bloom Filter是一個很長的二進位向量和一系列隨機對映函式，常用於需快速驗證元素是否「可能存在」或是「絕對不存在」在集合中，萬一結果為絕對不存在，就可以不用訪問主資料庫了。

此方法雖存在一定的錯誤機率，這個僞陽性特性對於解決快取穿透算是可以容忍，所以許多系統也是採用Bloom Filter作爲解決快取穿透的方法。


## Reference
[緩存雪崩 Cache Avalanche 緩存穿透 Cache Penetration 緩存擊穿 Hotspot Invalid 淺談緩存系統的三個問題](https://www.cnblogs.com/Leo_wl/p/12294093.html)

[redis - 快取雪崩、擊穿、穿透](https://totoroliu.medium.com/redis-%E5%BF%AB%E5%8F%96%E9%9B%AA%E5%B4%A9-%E6%93%8A%E7%A9%BF-%E7%A9%BF%E9%80%8F-8bc02f09fe8f)